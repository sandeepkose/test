name: POC Release Build

on:
  push:
    branches: ["**"]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  CACHE_VERSION: 1
  AWS_DEFAULT_REGION: eu-central-1
  SERVICE_NAME: invoice-extractor

jobs:
  build-push:
    name: Test, Build, and Push Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

  # https://kamrul.dev/dynamically-add-github-actions-ip-to-aws-security-group/
  deploy-on-server:
    name: Deploy docker on production server
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 # Fetch all history for better metadata

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Set up SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa          


          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@3.121.209.39 sudo -i <<'EOF'

      - name: Deploy / Update Service on Swarm Leader
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa \
            ubuntu@${{ steps.find-manager.outputs.manager_ip }} 'bash -s' <<EOF
            echo "üöÄ Deploying on Swarm Leader"

            # Login to GHCR and create Docker secret if needed
            echo "${{ secrets.PROD_GHCR_ACCESS_TOKEN }}" | docker login ghcr.io -u "${{ secrets.PROD_GHCR_USERNAME }}" --password-stdin

            if ! docker secret ls | grep -q ghcr-auth; then
              echo "${{ secrets.PROD_GHCR_ACCESS_TOKEN }}" | docker login ghcr.io -u "${{ secrets.PROD_GHCR_USERNAME }}" --password-stdin
              docker secret create ghcr-auth ~/.docker/config.json || true
            fi

            # Check OTL config is created.
            if ! docker config ls | grep -q otel-collector-config; then
              sed -i "s|dbpassword|${{ secrets.PROD_DB_PASSWORD }}|g" /root/otel-collector-config.yaml
              docker config create otel-collector-config /root/otel-collector-config.yaml || true
            fi

            # Count number of Ready + Active nodes
            NODE_COUNT=\$(docker node ls --format '{{.Status}} {{.Availability}}' | grep -c "Ready Active")
            echo "üìä Found \$NODE_COUNT Ready Active nodes"

            # Update NODE_COUNT in env
            if grep -q '^REPLICAS=' "/root/.env"; then
              echo "üîÅ Updating existing REPLICAS to \$NODE_COUNT"
              sed -i "s/^REPLICAS=.*/REPLICAS=\$NODE_COUNT/" "/root/.env"
            else
              echo "‚ûï Adding new REPLICAS=\$NODE_COUNT"
              echo "REPLICAS=\$NODE_COUNT" >> "/root/.env"
            fi

            echo "üö¢ Deploying stack..."
            set -a && source /root/.env && set +a && docker stack deploy --with-registry-auth --resolve-image=always -c /root/docker-compose.yaml ${{ env.SERVICE_NAME }}

            # Wait for updated tasks (of specific service) to become Running
            SERVICE_NAME=invoice-extractor_app
            TIMEOUT=300
            SLEEP=5
            ELAPSED=0

            echo "üöÄ Deploying service: \$SERVICE_NAME"
            echo "‚è≥ Waiting for all updated tasks (by image SHA) to be running..."

            while true; do
              PENDING_TASKS=""
              RUNNING_TASKS_COUNT=0

              # Get the current image SHA from service spec
              SERVICE_IMAGE_WITH_SHA=\$(docker service inspect "\$SERVICE_NAME" --format '{{"{{.Spec.TaskTemplate.ContainerSpec.Image}}"}}')

              # Get current running tasks
              TASKS=\$(docker service ps "\$SERVICE_NAME" --no-trunc --filter desired-state=Running \
                --format '{{"{{.ID}} {{.Image}} {{.CurrentState}}"}}')

              # Match only tasks using current image SHA
              MATCHING_TASKS=\$(echo "\$TASKS" | grep "\$SERVICE_IMAGE_WITH_SHA" || true)

              while IFS= read -r line; do
                TASK_ID=\$(echo "\$line" | awk '{print \$1}')
                TASK_STATE=\$(echo "\$line" | awk '{\$1=""; \$2=""; print \$0}' | xargs)

                if [[ "\$TASK_STATE" == Running* ]]; then
                  ((RUNNING_TASKS_COUNT++))
                  echo "            ‚úÖ Task \$TASK_ID is updated and running"
                else
                  PENDING_TASKS+="Task \$TASK_ID is not running yet (state: \$TASK_STATE)\n"
                fi
              done <<< "\$MATCHING_TASKS"

              echo "            ‚úÖ Total updated running containers: \$RUNNING_TASKS_COUNT"

              if [ -z "\$PENDING_TASKS" ]; then
                echo "            ‚úÖ All updated tasks are running with the correct image SHA."
                break
              else
                echo -e "            ‚è≥ Waiting for these tasks:\n\$PENDING_TASKS"
              fi

              if [ "\$ELAPSED" -ge "\$TIMEOUT" ]; then
                echo -e "\n            ‚ùå Timeout reached. Some updated tasks did not reach running state:"
                echo -e "\$PENDING_TASKS"
                exit 1
              fi

              sleep \$SLEEP
              ELAPSED=\$((ELAPSED + SLEEP))
            done





          EOF
